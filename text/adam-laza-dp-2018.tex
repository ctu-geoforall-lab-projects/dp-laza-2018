\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[czech, english]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[final,pdftex, colorlinks=false]{hyperref}
\usepackage{xcolor}
\usepackage{comment}
\usepackage{todonotes}
\usepackage{floatrow}
\usepackage{multirow}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{titletoc}
\usepackage{pdfpages}
\usepackage{hhline}
\usepackage{makecell}

\usepackage{listings}			%vkladani kodu
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue},
  breaklines=true,
  frame=lines,
}

%okraje
\usepackage[
left=35mm,
right=25mm,
top=40mm,
bottom=35mm]
{geometry}

\author{Adam Laža}

%%%%%%%%%%Prikazy%%%%%%%%%%
\renewcommand\baselinestretch{1.3}		%radkovani
\parskip=0.8ex plus 0.4ex minus 0.1 ex	%mezera mezi odstavci

\newcommand{\keywords}[2]{\noindent\textbf{#1: }#2}
\newcommand{\necislovana}[1]{%
\phantomsection
\addcontentsline{toc}{section}{#1}

%\newcommand{\exedout}{%
%  \rule{0.8\textwidth}{0.5\textwidth}%
%}


\section*{#1}
\markboth{\uppercase{#1}}{}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%Zahlavi%%%%%%%%%%%
\usepackage{fancyhdr}
\fancyhead[L]{CTU in~Prague}
\setlength{\headheight}{16pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagestyle{empty}

\newpage
\input{tituldp}

%\newpage
%\includepdf[pages={1}]{../formulare/zadani.pdf}

\newpage

\selectlanguage{english}
\begin{abstract}
\bigskip
\todo[inline]{Upravit abstract, aby odpovidal skutec strukture}
This master thesis is dedicated to isolation of PyWPS processes as one of the OGC WPS implementation. OGC WPS is Web Processing Service
Standard defined by Open Geospatial Consorcium. The practical part contains an introductory research where various solutions how 
to reach the process isolation are considered and described. Based on the research the Docker technology has been chosen for the 
implementation of process isolation.  In the theoretical part Docker technology is described as well as the OGC WPS standard and 
its PyWPS implementation written in Python.

\bigskip
\keywords{Keywords}
OGC WPS, PyWPS, Docker container, Python, process izolation, Web Processing Service.
\end{abstract}

\selectlanguage{czech}
\begin{abstract}
\bigskip
\todo[inline]{Překlad WPS - Webová Procesingová??? Služba, OGC??}
Tato diplomová práce se věnuje možnostem izolace procesů v rámci frameworku PyWPS jako jedné z implementací OGC WPS. Webová Procesingová 
Služba je standard vydaný a dále rozšiřovaný Open Geospatial Consorciem. Praktická část obsahuje úvodní rešerši, ve které jsou popsány
různé možnosti, jak izolace jednotlivých procesů dosáhnout. Na základě rešerše byla pro implementaci vybraná technologie Docker.
V teoretické části je popsána jak technologie Docker, tak OGC WPS standard a jeho implementace PyWPS napsaná v jazyce Python.

\bigskip
\keywords{Klíčová slova}
OGC WPS, PyWPS, Docker kontejner, Python, izolace procesu, Webová Procesingová Služba.
\end{abstract}

\selectlanguage{english}
%%%%Prohlaseni a podekovani
\newcommand{\odsaditodzhora}{\hskip1pt\vfill}
\newpage
\odsaditodzhora
\noindent {\bf Declaration of authorship}
I declare that the work presented here is, to the best of my knowledge and
belief, original and the result of my own investigations, except as acknowledged.
Formulations and ideas taken from other sources are cited as such


\begin{flushleft}
\begin{tabular}{cp{0.3\textwidth}c}
In Prague .................
& 
&
..................................
\\
&&
(author sign)
\end{tabular}

\end{flushleft}
\newpage

\odsaditodzhora
\noindent {\bf Acknowledgement}

\todo[inline]{Podekovani}

\newpage
\tableofcontents

\newpage
\pagestyle{fancy}

\necislovana{Introduction} 
There are data all around us. As the society is becoming more and more digitalized the amount of the data is getting
bigger and bigger. A lot of enterprises, institutions and organizations realize that these data hide a huge potential
they can profit from. However the data themself in their raw form are not usually sufficient to make an 
conclusion from them. More often the data need to be processed and used as an inputs data for some kind of analises. 
With the increasing number of gathered data a manual processing is almost unconceivable. Data are processed in an automatized way. 

Therefore, in order to be able to process the data independently of the type of acquisition, format or platform, 
it is necessary to define standards. Regarding spatial data, these standards are made by the Open Geospatial Consortium. 
Besides quite famous and used standards as WMS and WFS there also exists the WPS standard. The WPS standard defines an 
interface that facilitates the publishing of geospatial processes. It also provides rules how inputs and outputs are handled.
The WPS is only a standard and there are several implementations. This work is primarily focused on the \textit{PyWPS} framework.

\bigskip
The main topic of this thesis is process isolation. Process is just some geospatial operation which has its defined
inputs and outputs and which is deployed on the server. Server  is able to execute multiple 
processes at the same time. This thesis deals with the isolation of individual processes especially for security and 
performance reasons. With every process fully isolated so they cannot interact with each other the higher security level
is assured.

The thesis is composed of several parts. The introductory research discusses the current state of the PyWPS and the
other projects that implement the WPS standard, namely \textit{ZOO-Project} and \textit{52$^{\circ}$North}. Then the
introducing research offers possible soloutions to achieve process isolation. Various projects and technologies are
described and finally the Docker has been selected as the technology we try to implement in the practical part. Docker
has been selected as one of the most used technology for containerization. It puts every process into seperate
container so the isolation is ensured. Moreover Docker provides mechanism to pause, stop and start a container so it
looks like a possible solution for the future WPS 2.0.0 standard implementation which requires this funcionality. Using
Docker it also opens new posibilities like being able to deploy running job to cloud.

The technological background is covered in the second part. There is the WPS standard described, especially its operations
- \textit{GetCapabilities}, \textit{DesribeProcess} and \textit{Execute} - and inputs and outputs strucutres. There are also
\textit{PyPWS} and \textit{Docker} described.

Last part consists of the implementation description.
\todo[inline]{Doplnit uvod o implementaci}

I have choosen this topic to get in touch with another OGC standard. I also appreciate I can dive more into Docker technology
as it is a leader in containerization at the world.

\newpage
\part{Introductory research}

\newpage
\section{Current state}


\newpage
\section{Process isolation in PyWPS}
\subsection{Asynchonous requests}
Right now in PyWPS 4.0 version a PyWPS server instance is able to run multiple
concurrent processes in parallel. The server is configured for maximal amounts of concurrently running processes at
the same time and for maximal amount of waiting processes in a queue, to later start their execution once new
slots are available. If the new Execute request is received and the maximal amount is exceeded, the request is rejected
and user is informed in response (see Lst. \ref{lst:Isolation_rejected}).

\begin{lstlisting}[basicstyle=\small,caption={Resource exceeded exception},language=XML,label={lst:Isolation_rejected}]
<?xml version="1.0" encoding="UTF-8"?>
<ows:ExceptionReport xmlns:ows="http://www.opengis.net/ows/1.1" version="1.0.0">
    <ows:Exception exceptionCode="ServerBusy">
        <ows:ExceptionText>
            Maximum number of parallel running processes reached. Please try later.
        </ows:ExceptionText>
    </ows:Exception>
</ows:ExceptionReport>
\end{lstlisting}

To facilitate the management of  concurrent processes, process metadata are stored into a local database. This database is used
for logging , saving waiting Execute requests in the queue and invoking them later on.
This database will also enable the implementation of pausing, releasing and deleting running process. These features will
allow PyWPS to comply with WPS version 2.0.0.

\subsection{Current state}
At the beginning of every process execution its own temporary directory \textit{workdir} is created. During the execution
temporary files and continous outputs are stored in this folder. After successful execution final outputs are
moved to \textit{outputs} directory. Both directories \textit{outputs} and \textit{workdir} are configurable and user can
change path to them.

\bigskip
\begin{lstlisting}[basicstyle=\small,caption={pywps.cfg - mode parameter}]
[processing]
mode=multiprocessing
\end{lstlisting}

Current version of PyWPS offers two solutions for running parallel processes:
\begin{itemize}
\item Multiprocessing
\item Job Scheduler Extension\footnote{Job Scheduler Extension is currently only in develop branch of PyWPS.}
\end{itemize}

If the execute request is sent asynchronously the type of process constructor is choosen depending on configuration
parameter \textit{mode} in section \textit{processing} which is by default \textit{multiprocessing} or can be changed 
to \textit{scheduler}.

\bigskip
\begin{lstlisting}[basicstyle=\small,caption={processing.\_\_init\_\_.py},label={lst:Process_init},language=python]
def Process(process, wps_request, wps_response):
    """
    Factory method (looking like a class) to return the
    configured processing class.

    :return: instance of :class:`pywps.processing.Processing`
    """
    mode = config.get_config_value("processing", "mode")
    LOGGER.info("Processing mode: %s", mode)
    if mode == SCHEDULER:
        process = Scheduler(process, wps_request, wps_response)
    else:
        process = MultiProcessing(process, wps_request, wps_response)
    return process
\end{lstlisting}
\bigskip
\bigskip

\paragraph{Multiprocessing}
By default for   processes   running   in   the   background,   the   Python multiprocessing module is used – 
this makes it possible to use PyWPS on the Windows operating system too.

\paragraph{Job Scheduler Extension}
PyWPS scheduler extension offers possibilities to execute asynchronous processes out of the WPS server machine.
This extension enables to delegate execution of processes to a scheduler system like \textit{Slurm}, \textit{Grid Engine} 
and \textit{TORQUE} from Adaptive Computing. These schedular systems are usually located at \textit{High Performance Compute (HPC)}
centers.

\begin{figure}[h!]
\centering
\begin{floatrow}
\ffigbox{\includegraphics[width=0.33\textwidth]{img/Isolation_grid.jpg}}{\caption{Grid Engine}}{\label{fig:Isolation_grid}}
\ffigbox{\includegraphics[width=0.33\textwidth]{img/Isolation_slurm.png}}{\caption{Slurm}}{\label{fig:Isolation_slurm}}
\end{floatrow}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=0.5\textwidth]{img/Isolation_torque.png}
\caption{TORQUE}
\label{fig:Isolation_torque}
\end{figure}

The PyWPS scheduler extension uses the Python \textit{dill} library to dump and load the processing job to/from filesystem. The batch script executed on the scheduler system calls the PyWPS \textit{joblauncher} script with the dumped job status and executes the job (no WPS service running on scheduler). The job status is updated on the filesystem. Both the PyWPS service and the joblauncher script use the same PyWPS configuration. The scheduler assumes that the PyWPS server has a shared filesystem with the scheduler system so that XML status documents and WPS outputs can be found at the same file location. The interaction diagram how the communication between PyWPS and the scheduler works is displayed at
Fig. \ref{fig:Isolation_interaction}.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{img/Isolation_interaction.png}
\caption{Communication between PyWPS and scheduler, source: \cite{PyWPS_docs}}
\label{fig:Isolation_interaction}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{img/Isolation_slurm_usage.png}
\caption{Example of PyWPS scheduler extension usage with Slurm, source: \cite{PyWPS_docs}}
\label{fig:Isolation_slurm_usage}
\end{figure}

\subsection{Possible solutions}
In previous section there were described two mechanisms for running parallel processes. Nevertheless in case of Python module
\textit{Multiprocessing} the processes are not really isolated. They run concurrently but they can share resources and there are 
even methods like \textit{Pipe()} that enables comunication between processes.

On the otherhand \textit{Job Scheduler Extension} is dependent on \textit{dill} library as well as on some external scheduler
systems like \textit{Slurm}, \textit{Grid Engine} or \textit{TORQUE}.

\bigskip
In this section there are described some other solutions. Some of them were suggested by PyPWS developers with encouragment to
make a feasible study. Some of them were discovered during research on the internet forums like StackOverflow, some of them
were referenced in documentation of other projects. During the research two requirements were considered.

\begin{itemize}
\item Solution provides mechanism for full isolation. This is a must-have requirements.
\item Solution provides mechanism for start/pause/stop process execution. This is a nice-to-have requirements as this funcionality
will be required to comply WPS 2.0.0 standard.
\end{itemize}

\noindent
Finnaly these solutions were considered:
\begin{itemize}
\item Celery
\item Docker
\item psutil
\item SandboxedPython
\item VM
\end{itemize}

\subsubsection{Celery}
\textit{Celery} is a task queue system written in Python. It helps distribute work across threads and even machines. Basic term is \textit{task}.
Task is an unit of work and it is an input into the task queue. The task queue is constantly monitored for new work to perform.

To communicate between client and workers Celery uses a \textit{broker}. The communication is via messages. To initiate a task the
client adds a message to the queue and the broker then delivers the message to a worker. Multiple workers and brokers can be added
so there is assured high availability and horizontal scaling.

Celery provide worker remote control client in class \textit{celery.app.control.Control(app=None)}. The class offers these functions:
\begin{itemize}
\item\textbf{revoke} - Tell all (or specific) workers to revoke a task by id. If a task is revoked, the workers will ignore the task and not execute it after all.
\item\textbf{shutdown} - Shutdown worker(s).
\item\textbf{terminate} - Tell all (or specific) workers to terminate a task by id.
\end{itemize}

\subsubsection{Docker}
\textit{Docker} is one of the most used technology regarding containerization. This technology is described in depth in later chapter.

\subsubsection{psutil}
\textit{psutil} is Python library for process and system management. It handles system monitoring, limiting process resources
and the management of running processes. Its implementation is based on UNIX command line tools. psutil offers functions applied
to these sections:
\begin{itemize}
\item CPU - functions for CPU statistics such as CPU utilization percentage, frequency and others. 
\item Memory - functions for system memory usage and swap memory statistics.
\item Disks - functions for disk statistics such as disk usage or disk IO operations counter.
\item Network - functions for network IO operations or network connection statistics.
\item Sensors - functions for statistics about fans, battery or hardware temperature.
\item Others - functions for boot time and users statistics.
\item Processes - functions will be described in detail later.
\end{itemize}

\paragraph{Processes} - Class \textit{psutil.Process(pid=None)} represents an OS process with given pid. The class is
bound with a process via its PID. The \textit{Process} class offers these methods for starting/pausing:
\begin{itemize}
\item suspend() - Method suspends process using SIGSTOP signal.
\item resume() - Method resumes process using SIGCONT signal.
\item terminate() - Method terminates process using SIGTERM signal.
\item kill() - Method kills process using SIGKILL signal.
\end{itemize}

\subsubsection{Sandboxed Python}
The general goal of sandbox is to run applications securely inside isolated environment they cannot escape from and so
affect other parts of the system. Developers use them to run untrusted code inside. It is quite difficult to develope
fully sandboxed solution due to Python complexity. The basic problem is that Python introspection allows several ways
to excape out of the sandbox. True security requires an overall design with many security considerations included. Some
of the projects that can run Python code in sandbox are:
\begin{itemize}
\item PyPy
\item Jython
\end{itemize}

\paragraph{PyPy} PyPy is Python interpreter written in RPython that implements full Python language and very closely 
emulates the behavior of CPython. PyPy offers fully portable sandboxing feature similar to OS-level sandboxing (e. g. SECCOMP).
It is not sandboxing at the Python language level so it does not put any restriction on any Python funcionality.

Untrusted Python code that is intended to be sandboxed is launched in a subprocess, that is a special sandboxed version of PyPy.
All its inputs/outputs are not directly performed but are serialized to a stdin/stdout pipe. The outer process reads the pipe 
and afterwards decides which commands are allowed.

\paragraph{Jython} Jython is Python language interpreter for Java. Java offers strong sandboxing mechanisms. The security 
facility in Java that supports sandboxing is the \textit{java.lang.SecurityManager}. By default, Java runs without a 
SecurityManager.

\paragraph{pysandbox} A prove, that it is very difficult to develop some kind of sandbox with all security holes considered, could be a project call \textit{pysandbox}\footnote{\url{https://github.com/vstinner/pysandbox}}. After working on it for 3 years, during which
the project was used on various production servers by other developers, its author declared that the project is broken by
design. In his post to the python-dev mailing list \cite{PyDev_ML} the author explained that with every vulnerability founded
it became more difficult to actually write a real code:

\textit{
"To protect the untrusted namespace, pysandbox installs a lot of
different protections. Because of all these protections, it becomes
hard to write Python code. Basic features like "del dict[key]" are
denied. Passing an object to a sandbox is not possible to sandbox,
pysandbox is unable to proxify arbitary objects.}

\textit{
For something more complex than evaluating "1+(2*3)", pysandbox cannot
be used in practice, because of all these protections. Individual
protections cannot be disabled, all protections are required to get a
secure sandbox."}


\subsubsection{VM}

\newpage
\part{Technological background}

\newpage
\section{Web Processing Service}

\subsection{History}
First mention of the Web Processing Service was in October 2004. Back then it
was named Geoprocessing Service \cite{OGC_news}. The specification was first 
implemented as a prototype in 2004 by Agriculture and Agri-Food Canada (AAFC).
In its further development during a Geoprocessing Services Interoperability Experiment \cite{WPS_experiment} 
the name was changed to "Web Processing Service" to avoid the acronym GPS, since 
this would have caused confusion with the conventional use of this acronym for 
Global Positioning System \cite{WPS_standart_1.0}. The first version of WPS was released in
September 2005 \cite{WPS_first}. The experiment demonstrated that various clients
could easily access and bind to services which were set up according the WPS Implementation
specification.

Currently two major versions of WPS Standard exist. The WPS version 1.0.0 is currently used mostly.
If not explicitly said this thesis is dedicated to the version 1.0.0. The WPS version 2.0.0 was
released in 2015 \cite{WPS_second}.

\subsection{OGC}
\todo[inline]Doplnit kratky odstavec o OGC

\bigskip
\subsection{Web Processing Service}
The OGC Web -Processing Service (WPS) Interface Standard defines a standardized interface
that facilitates the publishing of geospatil processes. Also provides rules how to standardize
requests and responses for geospatial processing services. 

\textit{Process} means any operation on spatial
data from simple ones as maps overlay or buffering to highly complex as complicated global models. Any kind of GIS 
funcionality can be offered to clients across network with correctly configured WPS. 

\textit{Publishing} means
creating human-readable metadata that allow user to discover and use service as well as making 
available machine-readable binding information.

\textit{Data} can be both vector or raster data and can be delivered across the network or be available
at the server.

The interface does not specify any specific processes that can be implemented by a WPS nor any specific
data inputs or outputs. instead it specifies a generic mechanisms to describe any geospatial process and
data required and produced by the process. The interface does not only provide mechanisms for calculation
but also to identify required data, initiate the calculation and manage output data so clients can access it. 

\bigskip
Web Processing Service as one of the OGC web services scpecifies three types of requests which can be requested
by a client and performed by a WPS server. The implementation of these three requests is mandatory by by all servers:
\begin{itemize}
\item{GetCapabilities}
\item{DescribeProcess}
\item{Execute}
\end{itemize}

\textit{GetCapabilities} - The request returns to client a Capabilities document that describes the abilities
of the specific server implementation. It also returns the name and abstract of each of the processes that can
be run on a WPS instance.

\textit{DescribeProcess} - The request returns details about the processes offered by a WPS instance. Describes
required inputs and produces outputs and their allowable formats.

\textit{Execute} - The request allows a client to run a specified process with provided parameters and returns
produced outputs.

\begin{figure}[h!]
\centering
\includegraphics[width=0.78\textwidth]{img/WPS_class_diagram.png}
\caption{WPS interface UML description, source: \cite{WPS_standart_1.0}}
\label{fig:WPS_class_diagram}
\end{figure}

These operations are very similar to other OGC Web Services such as WMS, WFS, and WCS. Common interface aspects
are defined in the OpenGIS ® Web Services Common Implementation Specification \cite{OGC_common}. As seen at 
class diagram at Fig. \ref{fig:WPS_class_diagram} the WPS interface class inherits the GetCapabilities operation 
from OGCWebService interface class. The operations Execute and DescribeProcess are specific for the WPS. The WPS
operations are based on GET and POST requests.

\bigskip
\begin{table}[h!]
\catcode`\-=12
\centering
\begin{tabular}{|c|c|c|}
\hline
\multirow{2}{*}{Operation} & \multicolumn{2}{c|}{Request encoding} \\ \cline{2-3} 
                           & Mandatory          & Optional         \\ \hhline{|=|=|=|}
GetCapabilities            & KVP                & XML              \\ \hline
DescribeProcess            & KVP                & XML              \\ \hline
Execute                    & XML                & KVP              \\ \hline
\end{tabular}
\caption{Operations request encoding}
\label{tab:WPS_encoding}
\end{table}

The GetCapabilities and DescribeProcess shall use HTTP GET with KVP encoding and Execute operation shall use HTTP
POST with XML encoding. Summarized in Table \ref{tab:WPS_encoding}.

\bigskip
\subsubsection{GetCapabilities}
The GetCapabilities operation is mandatory. The operation allows clients to retrieve capabilities document (metadata)
from a server. The response XML document contains service metadata about server and all implemented processes description.

\todo[inline]{AcceptVersion vs version, AcceptFormats vs format}
\paragraph{GetCapabilities request}
\subparagraph{Request parameters}
\begin{table}[h!]
\catcode`\-=12
\centering
\begin{tabular}{|c|c|c|}
\hline
\thead{Name}               & \thead{Optionality and use} & \thead{Definition and format}    		\\ \hhline{|=|=|=|}
service=WPS                & Mandatory           & Service type identifier text 	\\ \hline
request=GetCapabilities    & Mandatory           & Operation name text              \\ \hline
AcceptVersion=1.0.0        & Optional            & Specification version            \\ \hline
Sections=All               & Optional            & \makecell{Comma-separated \\unordered list of sections} \\ \hline
updateSequence=XXX         & Optional            & \makecell{Service metadata \\document version}            \\ \hline
AcceptFormats=text/xml     & Optional            & \makecell{Comma-separated \\prioritized sequence of \\response formats} \\ \hline
\end{tabular}
\caption{GetCapabilities operation request URL parameters, source: \cite{OGC_common}}
\label{tab:WPS_GetCapabilities}
\end{table}

\begin{itemize}
\item\textit{service} - Mandatory parameter, WPS is only possible value.
\item\textit{request} - Mandatory parameter, GetCapabilities is only possible value.
\item\textit{version} - Optional parameter, version number. Three non-negative integers separated by decimal point. Servers and
their clients should support at least one defined version.
\item\textit{sections} - Optional parameter that contains a list of section names. Possible values are: \textit{ServiceIdentification,
ServiceProvider, OperationsMetadata, Contents, All}.
\item\textit{updateSequence} - Optional parameter for maintaining the consistency of a client cache of the contents of a service
metadata document. The parameter value can be an integer, a timestamp, or any other number or string.
\item\textit{updateSequence} - Optional parameter for maintaining the consistency of a client cache of the contents of a service
metadata document. The parameter value can be an integer, a timestamp, or any other number or string.
\item\textit{format} - Optional parameter that defines response format.
\end{itemize}

The GetCapabilities operation can be requested with parameters from table \ref{tab:WPS_GetCapabilities}. A corresponding
request URL looks like:
\url{http://localhost:5000/wps?service=WPS&request=GetCapabilities&Accept
Version=1.0.0&Section=ServiceIdentification,OperationsMetadata&update
Sequence=XXX&AcceptFormats=text/xml}

\bigskip
\paragraph{GetCapabilities response}
\subparagraph{Normal response}
When GetCapabilities operation requested a client retrieve service metadata document that contains sections specified in
\textit{sections} parameter. If the parameter value is \textit{All} or is not specified all sections retrieved.

\begin{itemize}
\item\textit{ServiceIdentification} - Server metadata.
\item\textit{ServiceProvider} - Server operating organization metadata.
\item\textit{OperationsMetadata} - Metadata about operations implemented by the WPS server, including URLs to request them.
\item\textit{ProcessOfferings} - List of processes with name and brief description implemented by the WPS server.
\end{itemize}
In addition to sections each GetCapabilities response should contains:
\begin{itemize}
\item\textit{version} - Specification version for GetCapabilities operation.
\item\textit{updateSequence} - Server metadata document version, value is increased whenever any change is made in complete service metadata document.
\end{itemize}

\subparagraph{GetCapabilities exceptions}
In case that WPS server encounters an error a client retrieve an exception report message with one of there exception code:

\begin{itemize}
\item\textit{MissingParameterValue} - GetCapabilities request does not contain a required parameter value.
\item\textit{InvalidParameterValue} - GetCapabilities request contains an invalid parameter value.
\item\textit{VersionNegotiation} - Any version from AcceptVersions parameter list does not match any version supported by the WPS server.
\item\textit{InvalidUpdateSequence} - Value of updateSequence parameter is greater than current value of service metadata updateSequence number.
\item\textit{NoApplicableCode} - Other exceptions.
\end{itemize}

\bigskip
\subsubsection{DescribeProcess}
The DescribeProcess operation is mandatory. The operation allows clients to retrieve a detailed description about one or more
processes implemented by a WPS server. The detailed information describe both required inputs and produced outputs and allowed
format.

\paragraph{DescribeProcess request}
\subparagraph{Request parameters}

\begin{itemize}
\item\textit{service} - Mandatory parameter, WPS is only possible value.
\item\textit{request} - Mandatory parameter, DescribeProcess is only possible value.
\item\textit{version} - Mandatory parameter, version number. Three non-negative integers separated by decimal point. Servers and
their clients should support at least one defined version.
\item\textit{Identifier} - Optional parameter, list of process names separated by comma. Another possible value is \textit{all}.
\end{itemize}

\begin{table}[h!]
\catcode`\-=12
\centering
\begin{tabular}{|c|c|c|}
\hline
\thead{Name}               & \thead{Optionality} & \thead{Definition and format}    		\\ \hhline{|=|=|=|}
service=WPS                & Mandatory           & Service type identifier text 	\\ \hline
request=DescribeProcess    & Mandatory           & Operation name text              \\ \hline
version=1.0.0              & Mandatory           & WPS specification version            \\ \hline
Identifier=buffer          & Optional            & \makecell{List of one or more process\\ identifiers, separated by commas} \\ \hline
\end{tabular}
\caption{DescribeProcess operation request URL parameters, source: \cite{OGC_common}}
\label{tab:WPS_DescribeProcess}
\end{table}

The DescribeProcess operation can be requested with parameters from table \ref{tab:WPS_DescribeProcess}. A corresponding
request URL looks like: \url{http://localhost:5000/wps?request=DescribeProcess&service=WPS&identifier=all&version=1.0.0}

\paragraph{DescribeProcess response}
\subparagraph{Normal response}
Normal response to DescribeProcess request contains or more process descriptions for requested process identifiers in 
\textit{ProcessDescriptions} structure. Each
process description contains detailed information about process in \textit{ProcessDescription} including process inputs and outputs description. Number
of inputs or outputs is not limited. Three types of input or outpus exist:
\todo[inline]{Doplnit popisy dat}
\begin{itemize}
\item\textit{LiteralData} - 
\item\textit{ComplexData} - 
\item\textit{BoundingBoxData} - 
\end{itemize}


\begin{table}[h!]
\catcode`\-=12
\centering
\begin{tabular}{|c|c|c|}
\hline
\thead{Name}               & \thead{Optionality} & \thead{Definition and format}    		\\ \hhline{|=|=|=|}
ProcessDescription	       & Mandatory           & \makecell{Full description of process \\ including inputs/outputs}             \\ \hline
service=WPS                & Mandatory           & Service type identifier text 	\\ \hline
version=1.0.0              & Mandatory           & Operation specification version          \\ \hline
lang			           & Mandatory           & Language identifier \\ \hline
\end{tabular}
\caption{Parts of ProcessDescriptions data structure, source: \cite{WPS_standart_1.0}}
\label{tab:WPS_ProcessDescriptions}
\end{table}

\begin{table}[h!]
\catcode`\-=12
\centering
\begin{tabular}{|c|c|c|}
\hline
\thead{Name}               & \thead{Optionality} & \thead{Definition and format}    		\\ \hhline{|=|=|=|}
Identifier      	       & Mandatory           & Process identigier             \\ \hline
Title 			           & Mandatory           & Process title 				  \\ \hline
Abstract		           & Optional            & Brief description              \\ \hline
Metadata		           & Optional            & \makecell{Reference to more metadata \\about this process} \\ \hline
Profile			           & Optional            & \makecell{Profile to which the WPS \\process complies} \\ \hline
processVersion	           & Mandatory           & Release version of process \\ \hline
WSDL    		           & Optional            & \makecell{Location of a WSDL document \\that describes this process} \\ \hline
DataInputs		           & Optional            & \makecell{List of the required and \\optional inputs} \\ \hline
ProcessOutputs	           & Mandatory           & \makecell{List of the required and\\optional outputs} \\ \hline
storeSupported	           & Optional            & \makecell{Complex data outputs can be \\stored by WPS server} \\ \hline
statusSupported	           & Optional            & \makecell{Execute response can be returned\\ quickly with status information} \\ \hline
\end{tabular}
\caption{Parts of ProcessDescription data structure, source: \cite{WPS_standart_1.0}}
\label{tab:WPS_ProcessDescription}
\end{table}

\subparagraph{DescribeProcess exceptions}
In case that WPS server encounters an error a client retrieve an exception report message with one of there exception code:

\begin{itemize}
\item\textit{MissingParameterValue} - GetCapabilities request does not contain a required parameter value.
\item\textit{InvalidParameterValue} - GetCapabilities request contains an invalid parameter value.
\item\textit{NoApplicableCode} - Other exceptions.
\end{itemize}

\bigskip
\subsubsection{Execute}
The Execute operation is mandatory. The operation allows clients to run a specified process implemented by a server.
Inputs can be included directly in the request body or be referenced as web accesible resource. The outputs are returned
in XML response document, either directly embedded within the response document or stored as resource accesible by
returned URL.

Ussualy the response document is returned right after the process execution is completed. However it is possible to get
response document right after sending request. In this case, returned response document contains a URL link from which the
final response document can be retrieved after completed process execution. Client can request execution status update to
find out the amount of processing remaining if the execution is not completed. Shown at Fig. \ref{fig:WPS_activity}.

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{img/WPS_activity}
\caption{Activity diagram when client requests storage of results, source: \cite{WPS_standart_1.0}}
\label{fig:WPS_activity}
\end{figure}

\paragraph{Execute request}
\begin{table}[h!]
\catcode`\-=12
\centering
\begin{tabular}{|c|c|c|}
\hline
\thead{Name}               & \thead{Optionality} & \thead{Definition and format}    		\\ \hhline{|=|=|=|}
service          	       & Mandatory           & Service type identifier text             \\ \hline
request			           & Mandatory           & Operation name text 				  \\ \hline
version			           & Mandatory           & WPS specification version              \\ \hline
Identifier   	           & Mandatory           & Process identifier \\ \hline
DataInputs		           & Optional            & \makecell{List of inputs provided \\ to this process execution} \\ \hline
ResponseForm	           & Optional            & Response type definition \\ \hline
language   		           & Optional            & Language identifier \\ \hline
\end{tabular}
\caption{Parts of Execute operation request, source: \cite{WPS_standart_1.0}}
\label{tab:WPS_ExecuteRequest}
\end{table}

\paragraph{Execute response}
Ussualy the Execute operation response document is an XML document. Only exception is in case when a response form
of \textit{RawDataOutput} is requested, execution is successful and only one complex output is created, then directly
the produced complex output is returned.

In ussual case response to Execute opetation is an ExecuteResponse XML document. The contents depend on ResponseForm 
request elements.

\begin{table}[h!]
\catcode`\-=12
\centering
\begin{tabular}{|c|c|c|}
\hline
\thead{Name}               & \thead{Optionality} & \thead{Definition and format}    		\\ \hhline{|=|=|=|}
service          	       & Mandatory           & Service type identifier text             \\ \hline
version			           & Mandatory           & WPS specification version              \\ \hline
language   		           & Mandatory           & Language identifier \\ \hline
statusLocation	           & Optional            & \makecell{Reference to location where current\\ExecuteResponse document is stored} \\ \hline
serviceInstance	           & Mandatory           & \makecell{Reference to location where current\\ExecuteResponse document is stored} \\ \hline
Process			           & Mandatory           & Process description \\ \hline
Status			           & Mandatory           & Execution status of the process \\ \hline
DataInputs		           & Optional            & \makecell{List of inputs provided \\ to this process execution} \\ \hline
OutputDefinitions          & Optional            & \makecell{List of definitions of outputs \\desired from executing this process} \\ \hline
ProcessOutputs             & Optional            & \makecell{List of values of outputs \\ from process execution} \\ \hline
\end{tabular}
\caption{Parts of ExecuteResponse data structure, source: \cite{WPS_standart_1.0}}
\label{tab:WPS_ExecuteResponse}
\end{table}

\subsection{WPS implementations}
The OGS WPS is just interface standard that provides rules for standardizing requests and response. It also defines how clients can request
the execution of defined processes and how the outputs are handled. There are several open-source projects that implement this standard 
across the platforms or programming languages.

\begin{itemize}
\item \textit{PyWPS} - Python implementation. This thesis is dedicated to this implementation.
\item \textit{Zoo Project} - WPS implementation written in C, Python and JavaScript.
\item \textit{WPS.NET} - WPS implementation on .NET platform.
\item \textit{52$^{\circ}$North WPS} - Java implementation.
\item \textit{deegree} - Java implementation of many OGC standards including WPS.
\item \textit{WPSint} - Java Spring implementation.
\end{itemize}

\newpage
\section{PyWPS}
\todo[inline]{Doplnit a prepsat}
PyWPS is a server side implementation of the OGC WPS standard in the Python programming language.
The first version of PyWPS started in 2006 as a student project. In 2007 PyWPS 2.0.0 was released supporting WPS 0.4.0.
Next year in 2008 PyWPS 3.0.0 was released with support for WPS 1.0.0. It was possible to run multiple WPS instances
with one PyWPS istallation. This version had simple code structure and contained examples of processes. The newest version 
is PyWPS 4.0.0 from September 2017.\cite{PyWPS_presentation}.

PyWPS itself is just interface implementation. It is not an analytic tool or engine so it does not perform any kind of
geospatil calculation nor provide any processing funcionality. PyWPS handles inputs, process execution and produces outputs
but it is up to user (typically developer or scientist) to provide own code that is deployed on the PyWPS server
instance and the server afterwards gets input data, evaluates them and calls the execute method.

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{img/pywps_logo.png}
\caption{PyWPS project logo}
\label{fig:pywps_logo}
\end{figure}

\subsection{PyWPS 4.0}
PyWPS-4 is the most current version of PyWPS. Rewritting from scratch involved this major changes:
\begin{itemize}
\item It is written in \textit{Python 3} with backwards support for Python 2.7.
\item It utilizes native Python bindings to existing projects (GRASS GIS).
\item New popular formats like \textit{GeoJSON}, \textit{KML} or \textit{TopoJSON} are reflected and their support is provided.
\item PyWPS project has changed the licence from \textit{GNU/GPL} to \textit{MIT}.
\item PyWPS 4.0 is implemented using the \textit{Flask} framework.
\item A C-based XML parser \textit{Lxml} is used to handle XML files.
\item \textit{OWSLib} structures are used for some data types.
\end{itemize}

\subsection{PyWPS-demo}
\todo[inline]{Doplnit info o demu a jeho pouziti}
PyWPS-demo is a small side project distributed with PyWPS. It is a simple demo instance of PyWPS server running on Flask with
several demo processes.

\newpage
\section{Docker}
\paragraph{Containerization} is a lightweight alternative to full machine virtualization. It involves encapsulating an application 
into a container with its own operating environment. It helps to run containerized application on any physical machine without any
worries about dependencies. The origin of containerization lies in the \textit{LinuX Containers {LXC}} format. Containerization
works only in Linux environments and can run only Linux applications.

Docker is not the only one technology for containerization. Other alternatives exist, it is \textit{Kubernets}, \textit{CoreOS rkt}, 
\textit{Open Contrainer Initiative (OCI)}, \textit{Canonical's LXD}, \textit{Apache Mesos and Mesosphere} and many others. 
However Docker is a leader on the field of contanerization and with most public traction is de facto considered as a container standard.
That's why the Docker was choosen for this thesis as a container technology. So from this point on any term \textit{container} refers to
Docker container.

\begin{figure}[h!]
\centering
\begin{floatrow}
\ffigbox{\includegraphics[width=0.33\textwidth]{img/Docker_kubernetes.png}}{\caption{Kubernetes}}{\label{fig:Docker_kubernetes}}
\ffigbox{\includegraphics[width=0.33\textwidth]{img/Docker_rkt.png}}{\caption{CoreOS rkt}}{\label{fig:Docker_rkt}}
\end{floatrow}
\end{figure}

\bigskip
\begin{figure}[h!]
\centering
\begin{floatrow}
\ffigbox{\includegraphics[width=0.24\textwidth]{img/Docker_lxd.png}}{\caption{Canonical's LXD}}{\label{fig:Docker_lxd}}
\ffigbox{\includegraphics[width=0.33\textwidth]{img/Docker_mesos.jpg}}{\caption{Apache mesos}}{\label{fig:Docker_mesos}}
\end{floatrow}
\end{figure}

\newpage
\begin{figure}[h!]
\centering
\includegraphics[width=0.6\textwidth]{img/Docker_logo}
\caption{Docker logo}
\label{fig:Docker_logo}
\end{figure}

\paragraph{Docker} is a Linux container technology that allows package and ship applications and everything it needs to execute into a standard
format, and run them on any infractructure.

\begin{figure}[h!]
\centering
\includegraphics[width=0.6\textwidth]{img/Docker_VM.png}
\caption{Virtual machine architecture, source \cite{Docker_docs}}
\label{fig:Docker_VM}
\end{figure}

\paragraph{Docker container vs. Virtual machine}
Both virtual machines and docker containers are two ways how to deploy multiple, isolated applications on a single platform. They
both offer a way to isolate an application and its dependencies into a self-contained unit that can run anywhere. They both offer
some kind of virtualization. They differ in architecture, see Fig. \ref{fig:Docker_VM}, \ref{fig:Docker_container}.

\noindent
Let's start with virtual machine (Fig. \ref{fig:Docker_VM}) and its layers description from bottom up:
\begin{itemize}
\item \textit{Infrastructure} - It can be a PC, developer's laptop, a physical server in datacenter but as well a virtual private
server in the cloud as Microsoft Azure or Amazon EC2.
\item \textit{Host OS} - Host operating system. In case of native hypervisor this layer is missing. In case of hosted hypervisor
it is probably some distibution of Linux, Windows or MacOS.
\item \textit{Hypervisor} - Also called virtual machine monitor (VMM). It allows to host several different virtual machines
on a single hardware. There are two types of hypervisors:
\begin{itemize}
\item Type 1 -  Also called \textit{bare metal} or \textit{native}. This type is run on the host's hardware to control it as well as manage 
the virtual machines on it. It is much faster and more efficient. This type hypervisors are KVM, Hyper-V or HyperKit.
\item Type 2 - So called \textit{embedded} or \textit{hosted} hypervisors. There hypervisors are run on a host OS as a software. They are slower
and less efficient on the other hand they are much easier to set up. It includes VirtualBox or VMWare Workstation.
\end{itemize}
\item \textit{Guest OS} - Guest operating system. Each VM require own guest operating system which is controlled by hypervisor. Each 
guest OS needs its own CPU and memory resources and starts on hundreds megabytes in size.
\item \textit{Bins/Libs} - Each guest OS needs various binaries and libraries for running the application. It can be \textit{python-dev} or \textit{default-jdk} packages as well as personal packages to run the application.
\item \textit{Application} - The application source code that is desired to be run isolated. Therefore each application or each version of application has to be run inside of its own guest OS with own copy of bins and libs. 
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=0.6\textwidth]{img/Docker_container}
\caption{Containers architecture, source \cite{Docker_docs}}
\label{fig:Docker_container}
\end{figure}

\noindent
Now, what is different regarding containers (Fig. \ref{fig:Docker_container})
\begin{itemize}
\item \textit{Infrastructure} - PC, laptop, physical or virtual server.
\item \textit{Host OS with container support} - Any OS capable of run Docker. All major distributions of Linux are supported and there are ways
to run Docker even on MacOs and Windows too.
\item \textit{Docker engine} - Also called Docker daemon. It is a service that runs in the beckground on host operating system. It manages all
interaction with containers.
\item \textit{Bins/Libs} - Binaries and libraries required by the application. They get built into special packages called \textit{Docker images}.
The Docker daemon runs those images.
\item \textit{Application} - Each application and its library dependencies get packed into the same Docker image. It is managed independently by the Docker daemon. 
\end{itemize}

\noindent
But the architecture is not the only one difference:
\begin{itemize}
\item Docker use Docker daemon to manage containers, hypervisor manages virtual machines.
\item The Docker daemon communicates directly with host OS and manage resources for each container.
\item VMs usually boot up in minute and more, containers start in seconds.
\item Docker virtualizes operating systems, using VMs is hardware virtualization.
\item VM and container vary in size. VMs start at hundreds of megabytes. Container can be smaller then one megabyte.
\item Containers share the kernel altough they are isolated. VMs are monolitic and stand-alone.
\end{itemize}

\paragraph{Dockerfile}
Dockerfile is a core file that contains instruction to be performed when an image is built. It usually consists from commands to install
packages, calls to other scripts, setting environmental variable, adding files or setting permissions. In Dockerfile there is also defined 
what image is to be used as base image for the build.

\paragraph{Dockerfile instructions}
\begin{itemize}
\item \textit{FROM} - The FROM instruction defines the base image for next instructions and initializes a new build stage. Every Dockerfile
has to start with FROM command. The only exception is ARG command which can be before FROM command.
\item \textit{ARG} - The ARG instruction defines a variable that users can pass at build-time to the builder.
\item \textit{ENV <key>=<value>} - The ENV instruction sets the environment variables. It is key-par value. 
\item \textit{LABEL} - The LABEL instruction adds metadata to an image. A LABEL is a key-value pair. It can be anything from version number to description.
\item \textit{ADD <src> <dest>} - The ADD instruction copies files or directories from source and adds them at the destination path. It also
unzip or untar files when added.
\item \textit{COPY <src> <dest>} - Similar to the ADD instruction it copies files or directories from source and adds them at the destination path. This command doesn't provide any kind of decompression.
\item \textit{RUN <command>} - The RUN instruction will execute any defined command and commit the results.
\item \textit{CMD ["executable","param1","param2"]} - The CMD instruction provides defaults for an executing container. It can include an
executable. In case the executable is ommited the CMD instruction must be used together with the ENTRYPOINT instruction. There can be only
one CMD instruction in Dockerfile. In case there is more CMD the last one will be used.
\item \textit{ENTRYPOINT} - The ENTRYPOINT defines a configuration of container that will run as executable.
\item \textit{WORKDIR /path/to/dir} - The WORKDIR instruction sets the working directory for any RUN, CMD, COPY and ADD instruction that follow
in Dockerfile.
\item \textit{EXPOSE} - The EXPOSE instruction informs Docker that the container listens on the specified network ports at runtime.
\item \textit{VOLUME} - The VOLUME instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers.
\end{itemize}

Except the FROM instruction, all the instructions can be defined from command line when starting docker container. There are more Dockerfile instructions however they are not relevant for this thesis as there are never used in practical part.

\newpage
\begin{lstlisting}[basicstyle=\small,caption={Dockerfile example}]
ARG VERSION=0.9.22
FROM phusion/baseimage:${VERSION}
LABEL maintainer="devs@pywps.example.net"

RUN apt-get update -y && apt-get install -y \
	git \
	python3 \
	python3-dev

RUN git clone https://github.com/geopython/pywps-flask.git
 
WORKDIR /pywps-flask
RUN pip3 install -r requirements.txt

RUN mkdir /etc/service/pywps4
COPY pywps4_service.sh /etc/service/pywps4/run
RUN chmod +x /etc/service/pywps4/run

EXPOSE 5000
ENTRYPOINT ["/usr/bin/python3", "demo.py","-a"]
\end{lstlisting}

\newpage
\part{Implementation}
\newpage
\todo[inline]{Popsat implementaci}

\newpage
\necislovana{Seznam použitých zkratek}

\begin{tabular}{ll}
\textbf{HPC}& High Performance Compute\\
\textbf{KVP}& Key Value Pair\\
\textbf{OGC}& Open Geospatial Consortium\\
\textbf{PID}& Process identifier \\
\textbf{URL}& Uniform Resource Locator\\
\textbf{VM}& Virtual Machine\\
\textbf{VMM}& Virtual Machine Monitor\\
\textbf{WPS}& Web Processing Service\\
\textbf{WMS}& Web Map Service\\
\textbf{WFS}& Web Feature Service\\
\textbf{WCS}& Web Coverage Service\\
\textbf{XML}& eXtensible Markup Language\\
\end{tabular}

\newpage
\begin{thebibliography}{99}
\label{Bibliography}
\bibitem{OGC_news}
Mark Reichardt \textit{OGC Newsletter - October 2004, OGC document number 04-043} [online].
URL: \textless\url{http://www.opengeospatial.org/pressroom/newsletters/200410}\textgreater
\bibitem{WPS_experiment}
Sam Bacharach \textit{OGC announces Web Processing Services Interoperability Experiment} [online].
URL: \textless\url{http://www.opengeospatial.org/pressroom/pressreleases/414}\textgreater

\bibitem{WPS_first}
Open Geospatial Consortium Inc. \textit{OpenGIS ® Web Processing Service, OGC document number 05-007r4, ver. 0.4.0} [online].
URL: \textless\url{https://portal.opengeospatial.org/files/?artifact_id=13149&version=1&format=doc}\textgreater

\bibitem{WPS_standart_1.0}
http://www.opengeospatial.org/pressroom/newsletters/200410

\bibitem{WPS_second}
Open Geospatial Consortium \textit{OGC® WPS 2.0 Interface Standard Corrigendum 1, OGC document number 06-121r3} [online].
URL: \textless\url{https://portal.opengeospatial.org/files/?artifact_id=13149&version=1&format=doc}\textgreater

\bibitem{OGC_common}
Open Geospatial Consortium Inc. \textit{OGC Web Services Common Specification, OGC document number 14-065} [online].
URL: \textless\url{https://portal.opengeospatial.org/files/?artifact_id=20040}\textgreater

\bibitem{Docker_docs}
Docker \textit{Docker documentation} [online].
URL: \textless\url{https://docs.docker.com/}\textgreater

\bibitem{PyWPS_paper}
Jáchym Čepický, Luís Moreira de Sousa \textit{New implementation of OGC Web Processing Service in Python programming language.} [online].
URL: \textless\url{https://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XLI-B7/927/2016/isprs-archives-XLI-B7-927-2016.pdf}\textgreater

\bibitem{PyWPS_presentation}
Jorge de Jesus, Luca Casagrande, Jáchym Čepický \textit{PyWPS a tutorial for beginners and developers} [online].
URL: \textless\url{https://www.slideshare.net/JorgeMendesdeJesus/pywps-a-tutorial-for-beginners-and-developers}\textgreater

\bibitem{PyWPS_docs}
PyWPS developers \textit{PyWPS documentation} [online].
URL: \textless\url{http://pywps.readthedocs.io/}\textgreater

\bibitem{PyDev_ML}
Victor Stinner \textit{The pysandbox project is broken} [online].
URL: \textless\url{https://lwn.net/Articles/574323/}\textgreater

\end{thebibliography}

\newpage
\section{Seznam tabulek a obrázků}
\listoftables

\listoffigures

\end{document}
